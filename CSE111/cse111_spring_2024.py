# -*- coding: utf-8 -*-
"""CSE111 Spring 2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14iy-DuP_EllyjVeKLwMSpXoooQWVzAmf
"""

#Class 1: DICTIONARY
#Python Crash Course Book: Chapter 6
#A very good resource for a quick overview: https://www.freecodecamp.org/news/python-dictionaries-detailed-visual-introduction/#:~:text=Dictionaries%20are%20built%2Din%20data,and%20delete%20key%2Dvalue%20pairs.
#Dictionary stores values in (key,value) pair. Each pair is known as an item.
#It means in order to store a value 'X' in a dictionary you need to have a unique characteristic related to X that needs to be used as KEY and X will be the value stored against that KEY.
#Dictionary is used if you need to store multiple values.
#Keys are used to retrieve values from Dictionary. So the values you want to store in a dictionary must have a unique charactersic using which you can identify each value and that unique characteristic will be used as the key.
#For example, if you want to store information of students, the unique characteristic using which you can identify the students is their student IDs. So student ID will be the KEY and other student information will be stored using that ID.
#Keys in a dictionary must be unique. A dictionary cannot have duplicate keys. Keys must be immutable which means keys can be strings, numbers or tuples while values can be of any data type.
dict1 = {} #Empty dictionary
#dict1 = dict() #Empty dictionary
dict1[16102439] = "Alice" #{16102439:"Alice"}
dict1[18301965] = "Bob" #{16102439:"Alice",18301965:"Bob"}
dict1.update({22102834:"John"})#{16102439:"Alice",18301965:"Bob",22102834:"John"}
print(dict1) #Printing whole dictionary at once.
print("1.----------------------------------------------")
#You need to use keys to access values in a dictionary.
#Lets say I want to print 'Bob' from dict1. In other words I want to print the name of the student whose ID is 18301965.
print(dict1[18301965])
print("2.----------------------------------------------")

#Why use dictionary if you know lists?

#Example 1: WITH LIST: Lets say you want to store information of 100000 students. Information means student ID, name, cgpa, department.
#How will you store them using a list?
studentList = [[16102439,"Alice",3.98,"CSE"],[18301965,"Bob",3.74,"CS"],[22102834,"John",3.81,"EEE"]] #I have used 3 students for reference.
#Lets say I want to print the name, department and CGPA of the student whose ID is 22102834. How can we do that?
for i in studentList:
  if i[0] == 22102834:
    print(f"Name:{i[1]}  Department:{i[3]}  CGPA:{i[2]}")

print("3.----------------------------------------------")

#Example 1: WITH DICTIONARY: Lets say you want to store information of 100000 students. Information means student ID, name, cgpa, department.
#How will you store them using a Dictionary?
studentDict = {}
studentDict[16102439] = ["Alice",3.98,"CSE"] #We are using student ID as key because its unique for every student.
studentDict[18301965] = ["Bob",3.74,"CS"]
studentDict[22102834] = ["John",3.81,"EEE"]
#Lets say I want to print the name, department and CGPA of the student whose ID is 22102834. How can we do that?
print(f"Name:{studentDict[22102834][0]}   Department:{studentDict[22102834][2]}   CGPA:{studentDict[22102834][1]}") #No need to use loop
print("4.----------------------------------------------")

#Example 2: CATEGORICAL data storage
#Lets say I want to store a list of movies based on their genre. How can we do that using a dictionary?
movieList = ["The Outpost","Action", "Onward","Animated","Saint Francis","Comedy","Greyhound","Action","Extra ordinary","Comedy"]
#The movies given above are in this format:[movie,genre,movie,genre,movie,genre,....................]
#Now lets store them in a dictionary
movieDict = {}
for i in range(0,len(movieList),2):#0,2,4,6,8
  if movieList[i+1] not in movieDict: #Checking whether the genre is present in the dictionary or not. If not need to create the genre as KEY first.
    movieDict[movieList[i+1]] = [movieList[i]] #Using a list in values because a genre can have multiple number of books.
  else:
    movieDict[movieList[i+1]].append(movieList[i]) #If the genre is already present in the dictionary, we will append the current book in the list under that genre.
print(movieDict)
print("5.----------------------------------------------")

#There are 3 important functions that you need to use to iterate over a dictionary.
#Those are: dict.keys(),dict.values(),dict.items()
dict2= {"Key1":"Value1","Key2":"Value2","Key3":"Value3"}
print(dict2.keys()) #It gives the list of keys.
print(dict2.values()) #It gives the list of values.
print(dict2.items())#It gives the items in key,value pair.
print("6.----------------------------------------------")
print("Keys:")
for k in dict2.keys():
  print(k,end=" ")
print("\n7.----------------------------------------------")
print("Values:")
for v in dict2.values():
  print(v,end=" ")
print("\n8.----------------------------------------------")
print("Items:")
for k,v in dict2.items(): #We need 2 variables k,v because items fuction returns a list of tuples where the first value in the tuple is the KEY and second value of the tuple is VALUE.
  print(f"{k}:{v}")
print("9.----------------------------------------------")
print("SORT BASED ON KEYS:")
#Sorting a dictionary based on Keys:
#Lets say we have a phonebook and we want to sort it alphabetically based on Name.
dict3 = {"Alice":"01762103434","Bob":"01890123123","Aeron":"01821323311","Berlin":"01621345234","Polin":"0174678761"}
phoneBook={}
for k in sorted(dict3.keys()):#sorted function returns a list of keys in sorted order.
  phoneBook[k] = dict3[k]
print(phoneBook)
print("10.----------------------------------------------")

#Class 3: Function
#A function is a block of code that gets executed when it is called.
#A function has 4  parts. They are: 1. Function name  2. Parameter list(Optional)   3.Body of the function.   4.return statement(Optional)
#Function Name: Function name is used to identify a function and call it. It should be meaningful which means from the name of the function we should be able to tell whats written inside the function.
#Parameter list(Optional): Parameter list is basically a set of variables that receives values from outside of the function when it is called.
#Parameter list is optional. You need to declare parameters only if you need to receive any information from outside of the function to inside of the function.
#The number of parameters should be exactly equal to the number of arguments passed to the function while calling it.
#Body of the function: The body of a function is basically the reason why we write a function. The body is a set of statements that gets executed when a function is called.
#Return statement(Optional): If you need to pass something/some value(Mostly the result of the body of a function) to outside of the function you can write that value in the return statement.
#The returned value replaces the call to the function which means the returned value is returned to the place from where the function was called.
#The return statement is the termination of a function. If a return statement is executed inside a function, that flags the termination of the function. No line inside the function gets executed after the execution of the return statement.
#If you have nothing to return there no need to write return statement.

#Basic structure of a function:
def sampleFunction(param1, param2):
  print("This is a sample function with 2 parameters.")
  print("Function Name: sampleFunction")
  print("Number of parameters: 2 (param1,param2)")
  print("The print statements represent the body of the function.")
  print(param1*param2)  #This is the return statement.
  #return param1 * param2
  #print("Hello World")
#sampleFunction(10,20)#You call a function with the function name. Since there are 2 parameters in the function, we need to pass exactly 2 arguments while calling the function.
print(sampleFunction(10.5,20))
#Function increases code reusability and readability. That's why we need to learn functions.
#Let's say we have a String "a2B1A3b6C5". Now we want to sort this string in such a way that we get the following string: "abABC13526".
#First we have to separate the lowercase, uppercase, odd digits and even digits in separate lists, then sort each of the 4 lists.
#You are not allowed to use any build in function like sort or sorted. So you have to write your own code of sorting.
#In stead of writing the codes of sorting 4 times, just write a function that can sort a list passed to it and call it whenever needed. This shows how function increases code reusability.
print("1-----------------------------------------------------")
#Local and Global Variables
x = "This is global X."

def f1():
  #global x
  #x = "This is local X."
  print("Inside the function:",x)#function will search if there is any local variable named 'x' , if not then it will look for a global variable named 'x'.

f1()
print("Outside the function:",x)
#parameters in a function are local variables to that function.
print("2-----------------------------------------------------")

#Pass by value and pass by reference
#Pass by value: int,string,float
#Pass by reference/address: List, Dictionary, User defined object

def f2(x):
  x=20
  #x="World"
  #x[0]=100
  print(x)
n=30 #Pass by value
#n = "Hello" #Pass by value
#n=[10,20,30,40] #Pass by reference
f2(n)
#f2(n,n[1])
print(n)
print("3-----------------------------------------------------")
#Dynamic argument (*args)
#If the number of arguments passed to a function is variable, then we use *args as the function parameter.
#No matter how many arguments are passed to the function, those will be received as a tuple in args.
#"args" is the name of a tuple. So it does not have to be named "args" all the time. You can use any name you want.
#Dynamic argument mechanism(*args) is used when you do not know the number of arguments to be passed to a function.
#Also it is used when the number of arguments passed to a function is too many.
def add(*args): # (10,20) , (10,20,30) , (10,20,30,40)
  print(args)
  print(f"Summation of {args} is {sum(args)}")

add(10,20)
add(10,20,30)
add(10,20,30,40)
print("4-----------------------------------------------------")
#Default Value
#Default value is used in parameters.
#When you do not pass a value for a parameter while calling the function, that parameter takes the default value assigned for it in the parameter list.
#In order to handle variable number of arguments passed to a function, you can use default value technique. However for that you must know the maximum number of arguments passed to the function.
def add(a,b,c=0,d=0):
  print(a,b,c,d)
  print(f"Sum:{a+b+c+d}")

add(10,20)
add(10,20,30)
add(10,20,30,40)

print("5-----------------------------------------------------")

#Returning multiple variables
#You can return multiple variables from a function by separating them using comma(,).
#The values will be returned in the form of a tuple.
def returnMultipleVariables():
  x = 10
  y = 20
  z = 5
  return x,y,z

print(returnMultipleVariables())

"""# Class 4: Introduction to OOP
Object-oriented programming (OOP) is a way of thinking about and organizing code for maximum reusability.

**There are four features of object-oriented programming to know:**
1. Encapsulation
2. Inheritance
3. Polymorphism
4. Abstraction

We will learn them one by one as we go throguh the semester.

**Why do we need to learn OOP?**

1. Modularity for easier troubleshooting
2. Reuse of code through inheritance
3. Security while sharing code
4. Increases readability
5. Scalability
6. Real world problem design

Popular languages that follow OOP are: Java, C++, C#, Python

Some good reads are:
1. https://www.roberthalf.com/blog/salaries-and-skills/4-advantages-of-object-oriented-programming
2. https://www.quora.com/Why-we-need-OOPs-in-Programming-language

"""

#Class 5 OOP 1 - Class and Objects
#Design
class Student:
    def __init__(self): #Constructor
        self.name = "XYZ"
        self.ID = 12345
        self.dept = "CSE"
        self.cg = 3.99
        print(self)


#Driver code
s1 = Student() #Object creation and initialization
print("1-----------------------------------------------------")
print(s1)#Hexadecimal address where the object is created will be printed.
print("2-----------------------------------------------------")
print(s1.name,s1.ID,s1.dept,s1.cg)#Before changing
s1.name  = "Sakib Al Hasan"
s1.ID = 9867
print("3-----------------------------------------------------")
print(s1.name,s1.ID,s1.dept,s1.cg)#After changing name and ID.

s2 = Student()#Object creation and initialization
print("4-----------------------------------------------------")
print(s2.name,s2.ID,s2.dept,s2.cg)

#The object referred by s2 is diffrenet from the object referred by s1.
#So changing the variables of the object referred to by s2 will have
#no effect on s1 and vise versa.
s2.name = "Tamim Iqbal"
s2.ID = 45678
print("5-----------------------------------------------------")
print(s2.name,s2.ID,s2.dept,s2.cg)
#changing the name and ID of the object referred by s2 has no effect on
#the variables of the object referred by s1.
print(s1.name,s1.ID,s1.dept,s1.cg)

#If we create another object whose location will be referred by s1,
#the reference to the previous object referred to by s1 will be lost.
#The previous object referred to by s1 will be removed from memory.
#Now s1 will refer to the newly created object.
#Please uncomment the lines for testing
#s1 = Student()
#print("6-----------------------------------------------------")
#print(s1.name,s1.ID,s1.dept,s1.cg)

#if we write s1 = s2 then s1 and s2 both will refer to the same object.
#the reference to the previous object referred to by s1 will be lost.
#The previous object referred to by s1 will be removed from memory.
#Please uncomment the lines for testing
#s1 = s2
#print("7-----------------------------------------------------")
#print(s1.name,s1.ID,s1.dept,s1.cg)
#print(s2.name,s2.ID,s2.dept,s2.cg)
#print("8-----------------------------------------------------")
#s1.name = "Imrul Kayes"
#print("9-----------------------------------------------------")
#print(s1.name,s1.ID,s1.dept,s1.cg)
#print(s2.name,s2.ID,s2.dept,s2.cg)
#As you can see, the changing the value of s1.name changed the value
#of both s1.name and s2.name because they both refer to the same object.

"""Topics to show in class 2:
1. Parameterized constructor
2. Basic method
3. Creating a new object under the same referecne variable.
4. Setting instance variable values based on input.
5. Creating a list of student objects.

"""

class Student:
  def __init__(self,name,ID,cg):
    self.name = name
    self.ID = ID
    self.cg = cg
    self.dept = "CSE"

  def printDetails(self):
    print(self)
    print(f"Name:{self.name}")
    print(f"ID:{self.ID}")
    print(f"Department:{self.dept}")
    print(f"CGPA:{self.cg}")

#Driver Code
n = int(input("How many students:"))
stList = []#DHK,RAJ
for i in range(n):
  name = input()
  ID = int(input())
  cg = float(input())
  s = Student(name,ID,cg)
  stList.append(s)
print("---------------------------")
print(stList)
print("----------------------")
for i in range(len(stList)):#0,1
  stList[i].printDetails()

#Name
#Account number
#Balance
class Account:
  def __init__(self,number,name,blnc):
    self.accNo = number
    self.accName = name
    self.balance= blnc

  def showAccountDetails(self):
    print(f"Account No:{self.accNo}")
    print(f"Account Name:{self.accName}")
    print(f"Balance:{self.balance}")

  def deposit(self,amount):
    self.balance += amount
    print("Deposit Successful!")
    self.showAccountDetails()

  def withdraw(self,amount):
    if self.balance - amount >= 500:
      self.balance -= amount
      print("Withdraw Successful!")
    else:
      print("Withdraw unsuccessful!")
      print("You do not have sufficient balance!")
    self.showAccountDetails()


acc1 = Account(4234234,"Lutfur",200000.0) #DHK
acc2 = Account(5345432,"Tausif",2000.0) #RAJ
acc1.showAccountDetails()
print("################################")
acc2.showAccountDetails()
print("################################")
acc1.deposit(300000.0)
print("################################")
acc2.deposit(100000.0)
print("################################")
acc1.withdraw(300000.0)
print("################################")
acc2.withdraw(150000.0)
print("################################")

"""##########################

Name: Alice

ID: 20103012

Department: CSE
##########################

Name: Bob

ID: 18301254

Department: EEE
##########################

Alice, you have taken 9.0 credits.

List of courses: CSE110, MAT110, PHY111

Status:Ok
##########################

Bob, you have taken 6.0 credits.

List of courses: BUS101, MAT120

Status: You have to take at least 1 more course.
##########################

Carol, you have taken 15.0 credits.

List of courses: MAT110, PHY111, ENG102, CSE111, CSE230

Status: You have to drop at least 1 course.
"""

class Student:
  def __init__(self,name,ID,dept):
    self.name = name
    self.ID = ID
    self.dept = dept

  def details(self):
    s = f"Name: {self.name}\n"
    s+= f"ID: {self.ID}\n"
    s+= f"Department: {self.dept}"
    return s
    #return None

  def advise(self,*args): #("MAT110", "PHY111", "ENG102","CSE111", "CSE230")
    status = "Ok"
    print(f"{self.name}, you have taken {len(args)*3.0} credits.")
    print(f"List of courses: {', '.join(args)}")
    if len(args) < 3:
      status =  f"You have to take at least {3-len(args)} more course."
    elif len(args) > 4:
      status = f"You have to drop at least {len(args)-4} course."
    print(f"Status:{status}")







# Do not change the following lines of code.
s1 = Student("Alice","20103012","CSE") #DHK
s2 = Student("Bob", "18301254","EEE") #RAJ
s3 = Student("Carol", "17101238","CSE") #COM
print("##########################")
print(s1.details())
print("##########################")
print(s2.details())
print("##########################")
s1.advise("CSE110", "MAT110", "PHY111")
print("##########################")
s2.advise("BUS101", "MAT120")
print("##########################")
s3.advise("MAT110", "PHY111", "ENG102","CSE111", "CSE230")
print("##########################")

#OOP class 4
#Method overloading
#Just uncomment the design and driver code of the Section you want to check.
class MethodOverloading:
#"-----------Section 1--------------------"
  def __init__(self,x=None,y=None):#(30,50)
    if x==None and y==None:
      print("This is a default constructor")
      self.x = 10
      self.y = 20
    else:
      print("This is an argumented constructor")
      self.x = x
      self.y = y
#"-----------Section 2--------------------"
  def m1(self):
    print("This is default m1")

  def m2(self):
    print("This is default m2")
#"-----------Section 3--------------------"
#Number of parameters
#Using default value
  # def m1(self,x=None,y=None):
  #   if x==None and y == None:
  #     print("This is default m1")
  #   elif y==None:
  #     print("This is 1 argumented m1")
  #   else:
  #     print("This is 2 argumented m1")

#Number of parameters
#Using dynamic arguments
  # def m1(self,*args):#(),(10),(10,29)
  #   if len(args)==0:
  #     print("This is default m1")
  #   elif len(args)==1:
  #     print("This is 1 argumented m1")
  #   elif len(args)==2:
  #     print("This is 2 argumented m1")

#"-----------Section 4--------------------"
#Types of parameters
  # def m1(self,x):
  #   if type(x) == int:
  #     print("This is 1 integer argumented m1")
  #   elif type(x) == str:
  #     print("This is 1 string argumented m1")

#"-----------Section 5--------------------"
#Order of parameters
  # def m1(self,x,y):
  #   if type(x) == int and type(y)==str:
  #     print("This is 2 argumented m1 and the order is: int , str")
  #   elif type(x) == str and type(y)==int:
  #     print("This is 2 argumented m1 and the order is: str , int")


print("-----------Section 1--------------------")
obj = MethodOverloading()
obj1 = MethodOverloading(30,50)
print("Default:",obj.x,obj.y)
print("Argumented:",obj1.x,obj1.y)
print("-----------Section 2--------------------")
#obj.m1()
#obj.m2()
print("-----------Section 3--------------------")
#obj.m1()
#obj.m1(10)
#obj.m1(10,29)
print("-----------Section 4--------------------")
#obj.m1(10)
#obj.m1("Hi")
print("-----------Section 5--------------------")
#obj.m1(10,"Hi")
#obj.m1("Hi",10)

#Overloading Practice-1
class Student:
  def __init__(self,name = None, dept = None):
    self.name = name
    self.dept = dept
    self.cList = []
    if name == None and dept == None:
      print("Student name and department need to be set")
    elif dept == None:
      print(f"Department for {self.name} needs to be set")
    else:
      print(f"{name} is from {dept} department")

  def update_name(self,newName):
    self.name = newName
  def update_department(self,newDep):
    self.dept = newDep

  def enroll(self,*args): # ("CSE110", "MAT110", "ENG091"), ("BUS101",),("MAT110", "PHY111")
    self.cList += list(args)
  def printDetail(self):
    print(f"Name: {self.name}")
    print(f"Department: {self.dept}")
    print(f"{self.name} enrolled in {len(self.cList)} course(s):")
    print(f"{', '.join(self.cList)}")

s1 = Student() #DHK
print("=========================")
s2 = Student("Carol") #RAJ
print("=========================")
s3 = Student("Jon", "EEE") #NOA
print("=========================")
s1.update_name("Bob")
s1.update_department("CSE")
s2.update_department("BBA")
s1.enroll("CSE110", "MAT110", "ENG091")
s1.enroll("BUS101")
s3.enroll("MAT110", "PHY111")
print("###########################")
s1.printDetail()
print("=========================")
s2.printDetail()
print("=========================")
s3.printDetail()

#OOP Class 5
#Tracing Practice-1
class msgClass:
    def __init__(self):
        self.content = 0
class Q5:
    def __init__(self):
        self.sum = 1
        self.x = 2
        self.y = 3
    def methodA(self):
        x, y = 1, 1
        msg = []
        myMsg = msgClass()
        myMsg.content = self.x
        msg.append(myMsg)
        msg[0].content = self.y + myMsg.content
        self.y = self.y + self.methodB(msg[0])
        y = self.methodB(msg[0],msg) + self.y
        self.sum = x + y + msg[0].content
        print(x," ", y," ", self.sum)

    def methodB(self, mg1, mg2 = None):
        if mg2 == None:
            x, y = 5, 6
            y = self.sum + mg1.content
            self.y = y + mg1.content
            x = self.x + 7 +mg1.content
            self.sum = self.sum + x + y
            self.x = mg1.content + x +8
            print(x, " ", y," ", self.sum)
            return y
        else:
            x = 1
            self.y += mg2[0].content
            mg2[0].content = self.y + mg1.content
            x = x + 4 + mg1.content
            self.sum += x + self.y
            mg1.content = self.sum - mg2[0].content
            print(self.x, " ",self.y," ", self.sum)
            return self.sum

q = Q5()
q.methodA()

#Tracing practice-2
class QuizA:
    def __init__(self):
        self.x = 3
        self.y = 5
        self.sum = 0
        self.c = 4


    def methodA(self, x):
        self.y = x + self.sum + self.c
        self.c += 1
        self.sum = x + self.y
        print(self.x, self.y, self.sum)


    def methodB(self, a):
        y = 3
        a.sum = self.x + self.sum
        a.methodA(a.sum)
        self.sum = a.x + self.c
        print(self.x, self.c, self.sum)

a = QuizA()
b = QuizA()
a.methodB(b)
b.methodA(a.y)

#OOP Clas 6.1
#Composition- HAS A Relationship
#Example 1: Teacher HAS Courses
#Trace table here: https://docs.google.com/spreadsheets/d/1WH6So-n5zq4ecDH9qdtYkkSiJhnoczJO0YlY2UnTZo8/edit?usp=sharing
class Teacher:
  def __init__(self,name,des):
    self.name = name
    self.des = des
    self.cList = []
  def addCourse(self,*args):#(COM,NOA) (BAR,)(CTG,NOA)
    self.cList+=list(args)
  def printDetails(self):
    print(f"Teacher Name:{self.name}")
    print(f"Designation:{self.des}")
    print(f"Number of Courses:{len(self.cList)}")
    print("List of courses:")
    for i in self.cList: #COM,NOA
      print(f"{i.code}:{i.title}")



class Course:
  def __init__(self,code,title):
    self.code = code
    self.title = title




t1 = Teacher("Matin Saad Abdullah","Professor")#DHK
t2 = Teacher("Sadia Hamid Kazi","Professor") #RAJ
c1 = Course("CSE110","Programming Language I") #COM
c2 = Course("CSE111","Programming Language II")#NOA
c3 = Course("CSE230","Discrete Mathematics") #BAR
c4 = Course("CSE421", "Computer Networks") #CTG
t1.addCourse(c1,c2) #(COM,NOA)
t2.addCourse(c3) #(BAR)
t2.addCourse(c4,c2)#(CTG,NOA)
print("-------------------------------")
t1.printDetails()
print("-------------------------------")
t2.printDetails()

#OOP Class 6.2
#Composition- HAS A Relationship
#Example 2: Library HAS Books
class Library:
  def __init__(self,name):
    self.name = name
    self.bList = {}#{"Fantasy":[HP,GOT],"Thriller":[MOTOE]}
    self.bCount=0
  def addBook(self,*args):#RAJ,COM,NOA
    for i in args:
      self.bCount+=1
      if i.gen not in self.bList:
        self.bList[i.gen] = [i.bName]
      else:
        self.bList[i.gen].append(i.bName)



class Book:
  def __init__(self,bName,gen):
    self.bName = bName
    self.gen = gen
l = Library("Ayesha Abed Library") #DHK
b1 = Book("Harry Potter","Fantasy") #RAJ
b2 = Book("Game of Thrones","Fantasy") #COM
b3 = Book("Martyr on the ocean express","Thriller") #NOA
b4 = Book("Stephen King","Fiction") #CTG
b5 = Book("Gone Girl","Thriller") #RNG
b6 = Book("American Gods","Fantasy") #BAR
l.addBook(b1,b2,b3)#RAJ,COM,NOA
l.addBook(b4,b5)#CTG,RNG
l.addBook(b6)
l.printDetails()

class Account:
  def __init__(self,number,name,blnc):
    self.accNo = number
    self.accName = name
    self.balance= blnc
    self.accType = 1  # 1 means current account   2 means saving account
    self.iRate = .05
  def showAccountDetails(self):
    print(f"Account No:{self.accNo}")
    print(f"Account Name:{self.accName}")
    print(f"Balance:{self.balance}")

  def deposit(self,amount):
    self.balance += amount
    print("Deposit Successful!")
    self.showAccountDetails()

  def withdraw(self,amount):
    if self.balance - amount >= 500:
      self.balance -= amount
      print("Withdraw Successful!")
    else:
      print("Withdraw unsuccessful!")
      print("You do not have sufficient balance!")
    self.showAccountDetails()

  def calculateInterest(self):
      print(f"Interest:{self.balance * self.iRate} taka.")


class Bank:
  def __init__(self,name,branch):
    self.name = name
    self.branch = branch
    self.accList = []

  def addAccount(self,*args):
    self.accList+=list(args)

  def printDetails(self):
    print(f"Bank Name:{self.name}")
    print(f"Branch:{self.branch}")
    print(f"Number of accounts:{len(self.accList)}")
    for i in self.accList:
      print(f"{i.accNo}: {i.accName}")




acc1 = Account(4234234,"Lutfur",200000.0) #DHK
acc2 = Account(5345432,"Tausif",2000.0) #RAJ
acc1.showAccountDetails()
print("################################")
acc2.showAccountDetails()
print("################################")
acc1.deposit(300000.0)
print("################################")
acc2.deposit(100000.0)
print("################################")
acc1.withdraw(300000.0)
print("################################")
acc2.withdraw(150000.0)
print("################################")
b1 = Bank("AB Bank","Gulshan")
b1.addAccount(acc1,acc2)
b1.printDetails()



class ABC:
  def __init__(self):
    self.__x = 10
    self.y = 20
  def getX(self):
    return self.__x
  def setX(self,newValue):
    self.__x = newValue

obj = ABC()
print(dir(obj))
print(obj._ABC__x)
obj._ABC__x= 100
print(obj.getX())

#OOP 7 - Class Variable
#Usage:
# 1. Count objects
# 2. Automatic ID generation
# 3. Memory management
class BracStudents:
  count = 0
  def __init__(self,name,ID):
    self.name = name
    self.ID = ID
    self.uni = "BRAC"

  def printDetails(self):
    print(f"Name:{self.name}\nID:{self.ID}\nUniversity:{self.uni}")

s1 = BracStudents("Alice",43123123)
s2 = BracStudents("Bob",6786534)
s3 = BracStudents("John",1231235)
s1.printDetails()
print("-------------")
s2.printDetails()
print("--------------")
s3.printDetails()
print(BracStudents.count)
print(s1.count)
print(s2.count)
print(s3.count)
s1.count= 15
print(BracStudents.count)
print(s1.count)
print(s2.count)
print(s3.count)

#OOP 7 - Class Variable
#Usage:
# 1. Count objects
# 2. Automatic ID generation
# 3. Memory management
class BracStudents:
  ID = 124400
  def __init__(self,name):
    self.name = name
    #self.ID = ID
    self.uni = "BRAC"
    BracStudents.ID += 1
    self.ID = BracStudents.ID


  def printDetails(self):
    print(f"Name:{self.name}\nID:{self.ID}\nUniversity:{self.uni}")

s1 = BracStudents("Alice")
s2 = BracStudents("Bob")
s3 = BracStudents("John")
s1.printDetails()
print("-------------")
s2.printDetails()
print("--------------")
s3.printDetails()

#OOP: 8.1 - Class method
class BracStudents:
  address = "Mohakhali"
  def __init__(self,name,ID):
    self.name = name
    self.ID = ID
  @classmethod
  def changeAddress(cls):
     print(cls)
     cls.address = "Merul Badda"

  def printDetails(self):
    print(f"Name:{self.name}\nID:{self.ID}")

s1 = BracStudents("Muntasir",43123123)
s2 = BracStudents("Zawad Ridwan",6786534)
s3 = BracStudents("Fahim Sadik",1231235)
BracStudents.changeAddress()

print(s1.address)



#OOP: 8.2 - Class method as factory mthod
from datetime import date
class Person:
  def __init__(self,name,age):
    self.name = name
    self.age = age

  @classmethod
  def createPersonfromDOB(cls,name,YOB):
    obj = Person(name,date.today().year-YOB)
    return obj
p1 = Person ("Zawad",20)
p2 = Person("Mustasir",21)
p3 = Person.createPersonfromDOB("Fahim",2002)
print(p3.name,p3.age)

#tracing tutorial: Class variable
#OOP 7.2: Class Variable tracing: same named instance and class variable
class FinalT6A:
    temp = 3
    def __init__(self, x, p):
        self.sum, self.y= 0, 2
        FinalT6A.temp += 3
        self.temp+=2
        self.y = FinalT6A.temp - p
        self.sum = self.temp + x
        self.temp =  self.y + x
        print(x, self.y, self.sum)

    def methodA(self):
        x, y = 0, 0
        y = y + self.y
        x = self.y + 2 + self.temp
        print(x, y, self.sum)

    def methodB(self, temp, n):
        x = 0
        FinalT6A.temp += 1
        self.y = self.y + (FinalT6A.temp)
        FinalT6A.temp -= 1
        x = x + 2 + n
        self.sum = self.sum + x + self.y
        print(x, self.y, self.sum)
q1 = FinalT6A(2,1)
#q2 = FinalT6A(3,4)
q1.methodA()

#OOP class 9
#Inheritance
class Product:
  def __init__(self,name,price):
    self.name = name
    self.price = price
  def printDetails(self):
    print(f"Name:{self.name}\nPrice:{self.price}")

class Book(Product):
  def __init__(self,name,price,aName,gen,isbn):
    super().__init__(name,price)
    self.author = aName
    self.gen = gen
    self.isbn = isbn
  def printDetails(self):
    super().printDetails()
    print(f"Author:{self.author}\nGenre:{self.gen}\nISBN:{self.isbn}")
  def __str__(self):
    return f"Book Name:{self.name}\nAuthor:{self.author}"
class Mobile(Product):
  def __init__(self,name,price,manu,imei):
    super().__init__(name,price)
    self.manu = manu
    self.imei = imei
  def __str__(self):
    return "Hello"
b1 = Book("Himu",400,"HA","Fantasy",5645756756857)
m1 = Mobile("iPhone 11 Pro Max",75000,"Apple",5645654757568568)
#b1 = Book("Himu",400)
#m1 = Mobile("iPhone 11 Pro max",75000)
# print(b1.name,b1.price,b1.author,b1.gen,b1.isbn)
# print(m1.name,m1.price,m1.manu,m1.imei)
b1.printDetails()
print("--------------------")
m1.printDetails()
print(dir(b1))
# print("--------------------")
print(b1) #b1.__str__()
# print(b1.__str__())
# print("--------------------")
print(m1) #m1.__str__()
print(isinstance(b1,Book))
print(isinstance(m1,Mobile))
print(isinstance(b1,Mobile))
print(isinstance(b1,Product))
print(isinstance(m1,Product))

#OOP class 9
#Inheritance
class Product:
  def __init__(self,name,price):
    self.name = name
    self.price = price
  def printDetails(self):
    print(f"Name:{self.name}\nPrice:{self.price}")

class Book(Product):
  def __init__(self,name,price,aName,gen,isbn):
    super().__init__(name,price)
    self.author = aName
    self.gen = gen
    self.isbn = isbn
  def printDetails(self):
     super().printDetails()
     print(f"Author:{self.author}\nGenre:{self.gen}\nISBN:{self.isbn}")

class Mobile(Product):
  def __init__(self,name,price,manu,imei):
    super().__init__(name,price)
    self.manu = manu
    self.imei = imei
  def printDetails(self):
     super().printDetails()
     print(f"Manufacturer:{self.manu}\nIMEI:{self.imei}")

b1 = Book("Himu",400,"HA","Fantasy",5645756756857)
m1 = Mobile("iPhone 11 Pro Max",75000,"Apple",5645654757568568)
#print(b1.name,b1.price,b1.author,b1.gen,b1.isbn)
print("--------------------")
#print(m1.name,m1.price,m1.manu,m1.imei)
#b1.printDetails()
print("--------------------")
#m1.printDetails()
#print(dir(b1))
# print("--------------------")
print(b1)#b1.__str
# print(b1.__str__())
# print("--------------------")
print(m1) #m1.__str__()
# print(isinstance(b1,Book))
# print(isinstance(m1,Mobile))
# print(isinstance(b1,Mobile))
# print(isinstance(b1,Product))
# print(isinstance(m1,Product))

#OOP Class 10.1
#Inheritance Practice-1
class Vehicle:
    def __init__(self):
        self.x = 0
        self.y = 0
    def moveUp(self):
        self.y+=1
    def moveDown(self):
        self.y-=1
    def moveRight(self):
        self.x+=1
    def moveLeft(self):
        self.x-=1
    def __str__(self):
        return '('+str(self.x)+' , '+str(self.y)+')'




print('Part 1')
print('------')
car = Vehicle()
print(car) #car.__str__()
car.moveUp()
print(car)
car.moveLeft()
print(car)
car.moveDown()
print(car)
car.moveRight()
print(car)
print('------')
print('Part 2')
print('------')
car1 = Vehicle2010()
print(car1)#car1.__str__()
car1.moveLowerLeft()
print(car1)
car2 = Vehicle2010()
car2.moveLeft()
print(car2)
print(car1.equals(car2))
car2.moveDown()
print(car1.equals(car2))

#OOP Class 10.1
#Inheritance Practice-1
class Vehicle:
    def __init__(self):
        self.x = 0
        self.y = 0
    def moveUp(self):
        self.y+=1
    def moveDown(self):
        self.y-=1
    def moveRight(self):
        self.x+=1
    def moveLeft(self):
        self.x-=1
    def __str__(self):
      return '('+str(self.x)+' , '+str(self.y)+')'

class Vehicle2010(Vehicle):
  def moveLowerLeft(self):
    super().moveLeft()
    super().moveDown()

  def equals(self,obj):#self=RAJ, Obj = COM
    return self.x == obj.x and self.y == obj.y


print('Part 1')
print('------')
car = Vehicle()
print(car) #car.__str__()
car.moveUp()
print(car)
car.moveLeft()
print(car)
car.moveDown()
print(car)
car.moveRight()
print(car)
print('------')
print('Part 2')
print('------')
car1 = Vehicle2010()
print(car1)#car1.__str__()
car1.moveLowerLeft()
print(car1)
car2 = Vehicle2010()
car2.moveLeft()
print(car2)
print(car1.equals(car2))
car2.moveDown()
print(car1.equals(car2))

#OOP Class 10.2
#Inheritance Practice-2
class Student:
    def __init__(self, name='Just a student', dept='nothing'):
        self._name = name
        self._department = dept
    def set_department(self, dept):
        self._department = dept
    def get_name(self):
        return self._name
    def set_name(self,name):
        self._name = name
    def __str__(self):
        return 'Name: '+self._name+' Department: '+self._department

print(BBA_Student())
print(BBA_Student('Humpty Dumpty'))
print(BBA_Student('Little Bo Peep'))

#OOP Class 10.3
#Multilevel Inheritance #Object-->GrandParent-->Parent-->Child
class GrandParent:
  def m1(self):
    print("This is Grand Parent m1")
class Parent(GrandParent): #m1,m2
  def m2(self):
    print("This is parent m2")
  def m1(self):
    print("This is Parent m1")

class Child(Parent): #m1,m2,m3
  def m3(self):
    print("This is child m3")
    #super().m1()
    Parent.m1(self)


obj = Child()
print(dir(obj))
Parent.m1(obj)

#OOP Class 10.3
#Multilevel Inheritance #Object-->GrandParent-->Parent-->Child
class GrandParent:
  def m1(self):
    print("This is Grand Parent m1")
class Parent(GrandParent): #m1,m2
  def m2(self):
    print("This is parent m2")
  def m1(self):
    print("This is parent m1")


class Child(Parent): #m1,m2,m3
  def m3(self):
    print("This is child m3")
    #super().m1()
    GrandParent.m1(self)


obj = Child()
obj.m1()
obj.m2()
obj.m3()

#OOP Class 10.4
#Multiple Inheritance
#Why multiple inheritance is not supported in Java?
class Father:
  def m1(self):
    print("This is father m1")
class Mother:
  def m1(self):
    print("This is mother m1")
  def m2(self):
    print("This is mother m2")
class Child(Mother,Father): #m1,m2
  def m3(self):
    print("This is child m3")

obj = Child()
obj.m1()
obj.m2()
obj.m3()

class GP:
  def m1(self):
    print("GP m1")

class Father(GP):
  def m3(self):
    print("asdasd")

class Mother():
  def m1(self):
    print("Mother m1")
  def m4(self):
    print("asdasd")

class Child(Father,Mother):
    def m5(self):
      print("asdasd")

obj = Child()
obj.m1()

#OOP Class 10.4
#Multiple Inheritance
#Why multiple inheritance is not supported in Java?
class Father:
  def m1(self):
    print("This is father m1")
class Mother:
  def m1(self):
    print("This is mother m1")
  def m2(self):
    print("This is mother m2")
class Child(Father,Mother): #m1,m2
  def m3(self):
    print("This is child m3")

obj = Child()
obj.m1()
obj.m2()
obj.m3()

#OOP Class 10.5
#When self and super() are same and different
class Parent:
  def m1(self):
    print("This is parent m1")
class Child(Parent):
  def m1(self):
    print("This is child m1")
  def m2(self):
    print("This is child m2")
    super().m1()
    self.m1()





obj = Child()
obj.m2()

#OOP Class 10.5
#When self and super() are same and different
class Parent:
  def m1(self):
    print("This is parent m1")
class Child(Parent):
  def m1(self):
    print("This is child m1")
  def m2(self):
    print("This is child m2")
    super().m1()
    self.m1()





obj = Child()
obj.m2()

#Does Private variable get inherited?YES  or NO
#Does class variable get inherited? YES or NO
#self.var: Instance var --> Own Class Var --> Parent class var
class Parent:
  temp = 6
  def __init__(self):                           #temp = 2000   x = 10
    self.temp = 2000
    self._x = 10
  def getX(self):
    return self._x

class Child(Parent):
  temp = 1000
  def __init__(self):
    self.temp = 123456
    super().__init__()

  def m1(self):
    #print(self._x)
    print(self.temp)

obj = Child()
obj.m1()
print(obj._x)

#Does Private variable get inherited?YES
#Does class variable get inherited? YES
#self var: Instance variable -> Own Class variable -> Parent Class variable
class Parent:
  temp = 6
  def __init__(self):
    self._x = 10
    self.temp = 123456
    print(self.temp)
  def getX(self):
    return self._x
  def m1(self):
    #print(super().getX())
    #print(Child.temp)  #Child Temp -> Parent Temp
    print(self.temp)


class Child(Parent):              #tem= "dasdsadasd"
  temp = 10
  def __init__(self):
    self.tem = "dasdsadasd"


obj = Child()
obj.m1()
#print(obj._x)

#Inheritance Tracing
#Part-1
#Instance variable --> Child Class variable --> Parent Class Variable
class A:
  temp = 3
  def __init__(self):
    self.sum = 0
    self.y = 0
    self.y = self.temp - 1
    self.sum = A.temp + 2
    A.temp -= 2

  def methodA(self, m, n):
    x = 0
    n[0] += 1
    self.y = self.y + m + A.temp
    A.temp += 1
    x = x + 2 + n[0]
    n[0] = self.sum + 2
    print(f"{x} {self.y} {self.sum}")

class B(A):
  x = 1
  def __init__(self, b = None):
    super().__init__()
    self.sum = 2
    if b == None:
      self.y = self.temp + 1
      B.x = 3 + A.temp + self.x
      A.temp -= 2
    else:
      self.sum = self.sum + b.sum
      b.sum = self.sum - A.temp
      B.x = b.x + self.x
  def methodB(self, m, n):
    y = [0]
    self.y = y[0] + self.y + m
    B.x = self.y + 2 +  self.temp - n
    self.methodA(self.x, y)
    self.sum = self.x + y[0] + self.sum
    print(f"{self.x} {y[0]} {self.sum}")


x= [23]
a1 = A()
b1 = B()
b2 = B(b1)
a1.methodA(1, x)
b2.methodB(3, 2)

#All in one tracing for finals
class A:
  temp = -5
  def __init__(self):
    self.sum = 0
    self.y = 0
    self.y = self.temp - 3
    self.temp = 7
    self.sum = self.temp + 2
    A.temp -= 2
  def methodA(self, m ,n):
    x = 1
    A.temp += 1
    self.y = self.y + m + self.temp
    x = x + 1 + n
    self.methodB(x,self.y)
    self.sum = self.sum + x + self.y
    print(f"{x} {self.y} {self.sum}")
  def methodB(self, m, n):
    y = 6
    y = self.y + m
    B.x = self.y + 3 + self.temp
    self.sum = y + self.sum
    print(f"{B.x} {y} {self.sum}")

class B(A):
  x = -10
  temp = 6
  def __init__(self, b = None):
    self.y = 4
    self.sum = 2
    if b == None:
      self.y = self.temp + 3
      self.sum = 3 + self.temp + 3
      self.temp -= 2
      super().__init__()
    else:
      self.sum = b.sum
      super().__init__()
      B.x = b.x
      #b.methodA(1,3)

  def methodA(self, m, n):
    x = 1
    self.temp += 1
    self.y = self.y + m + self.temp
    x = x + 7 + n
    self.sum = self.sum + x + self.y
    super().methodA(2,5)
    print(f"{x} {self.y} {self.sum}")
  def methodB(self, m, n):
    y = 3
    y = y + self.y
    B.x = self.y + 3 + self.temp
    self.sum = self.x + y + self.sum
    print(f"{B.x} {y} {self.sum}")

a1 = A()
b1 = B()
b2 = B(b1)
a1.methodA(5,7)
b1.methodA(3,2)
#b2.methodB(1,2)

#Inheritance practice
#Task 10 &15 from here: https://docs.google.com/document/d/1jyskr-SPZMnneQBOKKSx8Nq3z9NMwlmkhmdrWs3vBwk/edit
class Student:
    def __init__(self,name,ID):
        self.name = name
        self.ID = ID
    def Details(self):
        return "Name: "+self.name+"\n"+"ID: "+self.ID+"\n"



Bob = CSEStudent("Bob","20301018","Fall 2020")
Carol = CSEStudent("Carol","16301814","Fall 2020")
Anny = CSEStudent("Anny","18201234","Fall 2020")
print("#########################")
print(Bob.Details())
print("#########################")
print(Carol.Details())
print("#########################")
print(Anny.Details())
print("#########################")
Bob.addCourseWithMarks("CSE111",83.5,"CSE230",73.0,"CSE260",92.5)
Carol.addCourseWithMarks("CSE470",62.5,"CSE422",69.0,"CSE460",76.5,"CSE461",87.0)
Anny.addCourseWithMarks("CSE340",45.5,"CSE321",95.0,"CSE370",91.0)
print("----------------------------")
Bob.showGPA()
print("----------------------------")
Carol.showGPA()
print("----------------------------")
Anny.showGPA()

class Player:
    database = {}
    playerNo = 0
    def __init__(self, name, team, jerseyNo):
        self.name = name
        self.team = team
        self.jerseyNo = jerseyNo
    def __str__(self):
        return "Name:{}\nTeam:{}\nJersey No:{}".format(self.name,self.team,self.jerseyNo)


print("Number of players:", Player.playerNo)
print("Player Database:", Player.database)
print("#################################")
p1 = FootballPlayer("Lionel Messi","Barcelona",10,231)
print("------Details of the player------")
print(p1)#p1.__str__()
print("#################################")
p2 = FootballPlayer("Cristiano Ronaldo","Juventus",7,215)
print("------Details of the player------")
print(p2)
print("#################################")
p3 = FootballPlayer.createPlayer("Miroslav Klose","Lazio",11, 71,"11 Aug,2014")
print("------Details of the player------")
print(p3)
print("#################################")
print("Number of players:",Player.playerNo)
print("Player Database:",Player.database)

class Ticket:
  route_distance = {"Route A":400, "Route B":425,"Route C":350}
  fare_per_km = 20
  def __init__(self, route, journeyDate, price = 0):
    self.route = route
    self.journeyDate = journeyDate
    self.__price = price
  def setPrice(self, price):
    self.__price = price
  def getPrice(self):
    return self.__price
  def ticket_details(self):
    return f"Route: {self.route}\nJourney Date:{self.journeyDate}"



#Driver Code
ticket1 = BusTicket("Route A", "30 April, 2023","Nabil Enterprise", "F2")
print("Total ticket(s):", BusTicket.total_tickets)
print("1============================")
ticket1.calculate_fare()
print("2============================")
ticket1.ticket_details()
print("3============================")
ticket1.make_payment()
print("4============================")
ticket1.ticket_details()
print("5============================")
ticket2 = BusTicket("Route C", "26 April, 2023","Hanif Enterprise", "A2")
print("Total ticket(s):", BusTicket.total_tickets)
print("6============================")
ticket2.calculate_fare()
print("7============================")
ticket2.make_payment()
print("8============================")
ticket2.ticket_details()

class Mobile:
  countryCodes = {"880": "Bangladesh", "966": "India","455": "USA"}
  def __init__(self, model, simCardStatus):
    self.model = model
    self.__simCardStatus = simCardStatus
    print(f"Model {model} is manufactured.")
  def setSimCardStatus(self,status):
    self.__simCardStatus = status
    print("SIM card status updated successfully.")
  def getSimCardStatus(self):
    return self.__simCardStatus
  def __str__(self):
    return f"Mobile Phone Detail:\nModel:{self.model}\nSIM Card Status: {self.__simCardStatus}"


class Nokia(Mobile):
  def __init__(self,model,sim,balance=0):
    super().__init__(model,sim)
    self.balance = balance
    self.dialCallHistory=[]
  def __str__(self):
    s= super().__str__()
    s+=f"\nBalance:{self.balance} TK"
    return s
  def dialCall(self,phone):
    if super().getSimCardStatus() == False:
      return "No SIM card available!"
    else:
      if self.balance <= 0:
        return "Insufficient balance!"
      else:
        first3Digits = phone[:3]
        if first3Digits in Mobile.countryCodes.keys():
          self.dialCallHistory.append(phone)
          return f"Dialing the number {phone} to {Mobile.countryCodes[first3Digits]} region."

        else:
          return "Dialing is not allowed in this region."
  def changeSIMCardStatus(self):
    # if super().getSimCardStatus() == True:
    #   super().setSimCardStatus(False)
    # else:
    #   super().setSimCardStatus(True)
    super().setSimCardStatus(not super().getSimCardStatus())

  def rechargeSIMCard(self,amount):
    self.balance+= amount
    print(f"Recharge successful! Current balance {self.balance} TK.")



#Write your code here
N3110 = Nokia("N3110", False)
print("#######################################")
print(N3110)#N3110.__str__()
print("1======================================")
N1100 = Nokia("N1100", True,100)
print("#######################################")
print(N1100)
print("2======================================")
print(N3110.dialCall("88017196xxxx"))
print("3======================================")
N3110.changeSIMCardStatus()
print("4======================================")
print(N3110.dialCall("88017196xxxx"))
print("5======================================")
N3110.rechargeSIMCard(200)
print("6======================================")
print(N3110.dialCall("88017196xxxx"))
print("7======================================")
print(N1100.dialCall("45617196xxxx"))
print("8======================================")
print(N1100.dialCall("45517196xxxx"))
print(N1100.dialCall("96617196xxxx"))
print("9======================================")
print(f"Dial call history for {N1100.model}:{N1100.dialCallHistory}")
print(f"Dial call history for {N3110.model}:{N3110.dialCallHistory}")

class Mobile:
  countryCodes = {"880": "Bangladesh", "966": "India","455": "USA"}
  def __init__(self, model, simCardStatus):
    self.model = model
    self.__simCardStatus = simCardStatus
    print(f"Model {model} is manufactured.")
  def setSimCardStatus(self,status):
    self.__simCardStatus = status
    print("SIM card status updated successfully.")
  def getSimCardStatus(self):
    return self.__simCardStatus
  def __str__(self):
    return f"Mobile Phone Detail:\nModel:{self.model}\nSIM Card Status: {self.__simCardStatus}"

class Nokia(Mobile):
  def __init__(self,model,sim,balance = 0.0):
    super().__init__(model,sim)
    self.balance = balance
    self.dialCallHistory = []
  def __str__(self):
    return f"{super().__str__()}\nBalance: {self.balance} TK"
  def dialCall(self,num):
    if super().getSimCardStatus():
      if self.balance > 0.0:
        if num[0:3] in Mobile.countryCodes:
          self.dialCallHistory.append(num)
          return f"Dialing the number {num} to {Mobile.countryCodes[num[0:3]]} region."
        else:
          return "Dialing is not allowed in this region."
      else:
        return "Insufficient balance!"
    else:
      return "No SIM card available!"

  def changeSIMCardStatus(self):
    # if super().getSimCardStatus() == True:
    #   super().setSimCardStatus(False)
    # else:
    #   super().setSimCardStatus(True)
    super().setSimCardStatus(not super().getSimCardStatus())

  def rechargeSIMCard(self,amount):
    self.balance += amount
    print(f"Recharge successful! Current balance {self.balance} TK.")

#Write your code here
N3110 = Nokia("N3110", False)
print("#######################################")
print(N3110)#N3110.__str__()
print("1======================================")
N1100 = Nokia("N1100", True,100)
print("#######################################")
print(N1100)
print("2======================================")
print(N3110.dialCall("88017196xxxx"))
print("3======================================")
N3110.changeSIMCardStatus()
print("4======================================")
print(N3110.dialCall("88017196xxxx"))
print("5======================================")
N3110.rechargeSIMCard(200)
print("6======================================")
print(N3110.dialCall("88017196xxxx"))
print("7======================================")
print(N1100.dialCall("45617196xxxx"))
print("8======================================")
print(N1100.dialCall("45517196xxxx"))
print(N1100.dialCall("96617196xxxx"))
print("9======================================")
print(f"Dial call history for {N1100.model}:{N1100.dialCallHistory}")
print(f"Dial call history for {N3110.model}:{N3110.dialCallHistory}")

#All in one tracing for finals
#When you create an object of a child class, assume all the instance variables are of child class.
#Because once overridden, you can never access, parent class instance variables

#When you access variable using object's reference (self/reference variable), the value of the variable will be retrieved in the following order:
#Instance variable --> Own class's class variable --> Parent class's class variable
#Regardless from where you are accessing the variable(Parent/Child)

#When you call an instance method using an object's referene(self/reference variable), the method will be called in the following order:
# Own class's instance method --> Parent class's instance method
#Regardless from where you are calling the method.


class A:
  temp = -5
  def __init__(self):
    self.sum,self.y = 0,0
    self.y = self.temp - 3
    self.temp = 7
    self.sum = self.temp + 2
    A.temp -= 2
    #print(self.sum,self.y,self.temp,A.temp)
  def methodA(self, m ,n):
    x = 1
    A.temp += 1
    self.y = self.y + m + self.temp
    x = x + 1 + n
    self.methodB(x,self.y)
    self.sum = self.sum + x + self.y
    print(f"{x} {self.y} {self.sum}")
    return self.sum

  def methodB(self, *args):
    y = 6
    y = self.y + args[0]
    B.x = self.y + 3 + self.temp
    self.sum = y + self.sum + args[1]
    print(f"{B.x} {y} {self.sum}")

class B(A):
  x = -10
  temp = 6
  def __init__(self, b = None):
    temp = 16
    self.y = 4
    self.sum = 2
    if b == None:
      self.y = self.temp + 3
      self.sum = 3 + self.temp + 3
      self.temp -= 2
      super().__init__()
    else:
      self.sum = b[0].sum
      super().__init__()
      B.x = b[0].sum
      b[0].methodB(1,3)
    #print(self.sum,self.y,self.temp)

  def methodA(self, m, n):
    x = 1
    self.temp += 1
    self.y = self.y + m + self.temp
    x = x + 7 + n
    self.sum = x + super().methodA(2,5) + self.y
    print(f"{x} {self.y} {self.sum}")
  def methodB(self, m, n):
    y = 3
    y = y + self.y
    B.x = self.y + 3 + self.temp
    self.sum = self.x + y + self.sum
    print(f"{B.x} {y} {self.sum}")

obj = []
obj.append(A())
obj.append(B())
obj.append(B(obj))
obj[1].methodB(5,7)
obj[2].methodA(3,2)